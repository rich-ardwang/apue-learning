#include <signal.h>
#include <errno.h>

/*
 * <signal.h> usually defines NSIG to include signal number 0.
 */
// SIGBAD宏判断信号编号是否为1-31，如果不在这个范围内，则视为无效的信号
// 类型。（NSIG一般被定义为32）
#define SIGBAD(signo)((signo) <= 0 || (signo) >= NSIG)

// 如果定义了NSIG，那么sigset_t则被定义为unsigned long，即4字节无符号
// 整数，这样刚好能容纳下31种不同的信号。
// 该函数将一种信号保存在信号集中。
int
sigaddset(sigset_t *set, int signo)
{
	// 利用SIGBAD宏判断信号编号是否有效（1-31）。
	if (SIGBAD(signo)) {
		// 如果信号编号无效，设置errno为无效参数，然后返回-1。
		errno = EINVAL;
		return (-1);
	}
	// 位操作：把1左移（信号编号-1）位，得到的结果再和信号集进行或操作。
	// 这样就可以把1-31种信号放置在信号集中相应的比特位上，将该位置为1,
	// 说明该位上保存了相应编号的信号。
	// 0 1  1  1  1  1  1  1  ......  1 1 1 1  1 1 1 1   |  set
 	//   31 30 29 28 27 26 25         8 7 6 5  4 3 2 1   |  signo
	*set |= 1 << (signo - 1);		/* turn bit on */
	// 操作完毕后返回0
	return (0);
}

// 该函数从信号集中移除一种信号。
int
sigdelset(sigset_t *set, int signo)
{
	// 利用SIGBAD宏判断信号编号是否有效（1-31）。
	if (SIGBAD(signo)) {
		// 如果信号编号无效，设置errno为无效参数，然后返回-1。
		errno = EINVAL;
		return (-1);
	}
	// 位操作：把1左移（信号编号-1）位，得到的结果取反，最后和信号集进行与操作。
	// 这样就可以把某种信号所在信号集中相应的比特位置为0。
	*set &= ~(1 << (signo - 1));	/* turn bit off */
	// 操作完毕后返回0
	return (0);
}

// 该函数判断某种信号是否保存在信号集中。
int
sigismember(const sigset_t *set, int signo)
{
	// 利用SIGBAD宏判断信号编号是否有效（1-31）。
	if (SIGBAD(signo)) {
		// 如果信号编号无效，设置errno为无效参数，然后返回-1。
		errno = EINVAL;
		return (-1);
	}
	// 位操作：把1左移（信号编号-1）位，得到的结果和信号集进行与操作，
	// 如果结果为0，说明信号集中不存在该种信号，返回false，
	// 如果结果为1，说明信号集中保存了该种信号，返回true。
	return ((*set & (1 << (signo - 1))) != 0);
}

// 点评
// APUE介绍的全部信号也就只有45种，V7支持15种，SVR4和4.4BSD均支持31种，
// FreeBSD 8.0支持32种，MacOS X 10.6.8和Linux 3.2.0都支持31种，而
// Solaris 10支持40种信号。
// 不存在编号为0的信号，kill()函数对编号为0的信号有特殊用途，POSIX.1称
// 这种信号为空信号。
// 既然信号种类这么少，而多数平台都支持31种不同的信号，那么考虑如何把这些
// 信号保存为一个信号集合呢？
// 且因为int整型变量为4字节32位，所以刚好可以使用int型的每个位来代表一种
// 信号，这样一个信号集合就可以只用4字节来存储即可。

// 基于上面的分析，本例给出了信号集合的一种简单的实现，如将一个信号加入信号
// 集、从信号集中移除某个信号、判断信号集中是否存在某种信号等等。
// 本程序提供的实现，信号集只能容纳编号为1-31，总计31种不同的信号，如果信号
// 种类过多，那就需要其他的实现方法了。
