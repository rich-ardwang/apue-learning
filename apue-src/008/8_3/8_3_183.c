#include "apue.h"

// 全局变量声明
int		globvar = 6;		/* external variable in initialized data */
char	buf[] = "a write to stdout\n";

int
main(void)
{
	// 局部变量
	int		var;		/* automatic variable on the stack */
	pid_t	pid;  // 进程ID

	// 给局部变量var赋值
	var = 88;
	// 调用write()系统调用向标准输出写入一个字符串。
	// sizeof()计算出的字符串长度包含结束符null，而strlen()计算出字符串长度不包含null。
	// sizeof()和strlen()的另一个区别是，前者在编译时计算长度，后者需要运行时执行一次函数调用。
	// 这里将null字符减掉，避免把它写入标准输出流。
	if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)
		err_sys("write error");
	// 打印告知在执行fork()函数之前，此时还没有冲洗标准输出流。
	printf("before fork\n");	/* we don't flush stdout */

	// 执行fork()函数，会创建出当前进程的子进程。
	// fork()函数只被当前进程调用一次，但是会返回两次，一次在父进程中返回，
	// 另外一次在子进程中返回。
	// fork()返回值小于0表示执行fork()失败。
	if ((pid = fork()) < 0) {
		err_sys("fork error");
	// fork()返回值等于0表示此进程为子进程。
	// 因为子进程可以调用getpid()知道自己的进程id，也可以调用getppid()知道自己的父进程id。
	// 所以不需要fork()返回pid给它。
	} else if (pid == 0) {		/* child */
		// 子进程将全局变量加1
		globvar++;				/* modify variables */
		// 子进程将局部变量加1
		var++;
	// fork()返回值大于0表示返回值是子进程的pid，也表示此进程为父进程。
	// 因为父进程可以调用getpid()知道自己的进程id，也可以调用getppid()知道自己的父进程id，
	// 但是没有办法知道自己的子进程id，所以需要fork()返回子进程的pid给它。
	} else {
		// 父进程睡眠10秒
		sleep(10);				/* parent */
	}

	// 父子进程都打印出自己的进程id、全局变量和局部变量。
	printf("pid = %ld, glob = %d, var = %d\n", (long)getpid(), globvar, var);
	// 父子进程都正常退出。
	exit(0);
}

// 点评
// 本例主要演示使用fork()函数来创建子进程，通过该程序我们可以知道fork()函数的基本用法
// 与一些注意事项。
// 需要注意的是fork()被调用后，父子进程到底谁先被执行这是不确定的，内核使用的调度算法有关。
// 本例执行完fork()后，父进程故意睡眠10秒，是给子进程充足的时间，让它完成对全局变量和局部
// 变量的修改，然后确保子进程已正常退出后，自己再正常退出。

// 父子进程
// 子进程获得父进程数据空间、堆和栈的副本，父子进程不共享这些存储空间的部分，他们只是共享正文段。
// 由于经常fork子进程后，让其立即调用exec更换为一个全新的进程，所以让子进程完全获得父进程的数据
// 空间、堆和栈的副本太没效率，进而出现写时复制技术(Copy-On-Write, COW)，即内核将这些存储空间
// 标记为只读，给父子进程共享，父子进程有任何一方想要修改存储空间时，内核才为需要修改的那片区域的
// 内存制作一个副本，通常是虚拟存储系统中的一页。

// 实验过程与结果
// 1.执行./8_3_183，输出结果：
// a write to stdout
// before fork
// pid = 14071, glob = 7, var = 89
// pid = 14070, glob = 6, var = 88
// 2.执行./8_3_183 > temp.out，cat temp.out，结果：
// a write to stdout
// before fork
// pid = 14800, glob = 7, var = 89
// before fork
// pid = 14799, glob = 6, var = 88

// 结果分析
// 1.子进程改变了全局变量和局部变量，但这些都是它自己的副本，并没有影响父进程，
// 可见存储区域父子进程各有自己的副本。
// 2.wirte()系统调用无缓冲，所以"a write to stdout"会立即写入标准输出。
// 3.直接执行时，"before fork"仅输出一次，因为printf()是标准IO库函数，当
// 进程连接终端时，标准库是行缓冲，否则是全缓冲，而行缓冲由'\n"换行符冲洗流，所以
// 在调用fork()前，流已经被冲洗到标准输出了。
// 4.当执行文件重定向时，"before fork"会输出两次，因为重定向时标准IO库为全缓冲，
// fork()被执行前，"before fork\n"还在缓冲区，没有被冲洗，而fork后子进程继承了
// 父进程的IO缓冲区，也继承了文件重定向，此时它和父进程共享同一文件读写权。
// 当子进程执行exit(0)退出后，引发IO缓冲区冲洗，所以子进程的"before fork\n"写入
// 了文件，然后父进程执行exit(0)退出后，也引发IO缓冲区冲洗，将自己的"before fork\n"
// 写入同一个文件。

// 父子进程文件共享
// 父子进程共享同一个文件表项，即共享文件状态标志、当前文件偏移量和v节点指针。
// 如果使用父子进程操作同一个文件时，要注意进程间同步的问题。

// 子进程继承父进程资源总结
// 1.父进程数据空间、堆和栈。
// 2.父进程打开的所有文件的描述符，子进程相当于把父进程的所有打开文件的描述符都给dup()了。
// 3.实际用户ID、实际组ID、有效用户ID和有效组ID。
// 4.附属组ID
// 5.进程组ID
// 6.会话ID
// 7.控制终端
// 8.设置用户ID标志和设置组ID标志
// 9.当前工作目录
// 10.根目录
// 11.文件模式创建屏蔽字
// 12.信号屏蔽和安排
// 13.对任一打开文件描述符的执行时关闭(close-on-exec)标志
// 14.环境
// 15.连接的共享存储段
// 16.存储映像
// 17.资源限制

// 父子进程区别
// 1.fork的返回值不同
// 2.进程本身的进程ID不同
// 3.进程的父进程ID不同
// 4.子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值被设置为0。
// 5.子进程不继承父进程设置的文件锁。
// 6.子进程的未处理闹钟被清除。
// 7.子进程的未处理信号集设置为空集。

// 使用fork的业务场景
// 1.网络服务场景：父进程等待客户端连接，当连接到达后，父进程fork子进程，让子进程处理客户端请求。
// 2.shell进程处理场景：shell执行命令时，首先fork子进程，然后让子进程调用exec类函数去执行命令。
