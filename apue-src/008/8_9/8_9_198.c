#include "apue.h"

// 全局静态函数声明
static void charatatime(char *);

int
main(void)
{
	// 进程ID
	pid_t		pid;

	// 初始化父子进程同步机制
	TELL_WAIT();

	// 父进程fork子进程
	if ((pid = fork()) < 0) {
		err_sys("fork error");
	} else if (pid == 0) {  // child
		// 让父进程先执行，子进程阻塞等待。
		// 当收到父进程已完成的通知后，解除阻塞。
		WAIT_PARENT();			/* parent goes first */
		// 此时父进程已经写完了，子进程将如下字符串写入标准输出。
		charatatime("output from child8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888\n");
	} else {  // parent
		// 父进程先将如下字符串写入标准输出。
		charatatime("output from parent999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n");
		// 写入完成后通知子进程。
		TELL_CHILD(pid);
	}
	// 父子进程退出，全缓冲时可引发冲洗流操作。
	exit(0);
}

// 该函数将标准IO缓冲区关闭，改为无缓冲，然后输出字符串。
static void
charatatime(char *str)
{
	char		*ptr;
	int			c;

	// 自定义标准IO的缓冲区，这里将标准输出缓冲区关闭，即改为无缓冲。
	setbuf(stdout, NULL);		/* set unbuffered */
	// 使用for循环方式一个字符一个字符去读取。
	for (ptr = str; (c = *ptr++) != 0; )
		// 每读取一个字符就向标准输出写入一个，注意是无缓冲。
		putc(c, stdout);
}

// 点评
// 改进8_9_197程序以避免产生竞争条件。
// 本例加入了父子进程的同步机制，该进程同步机制利用信号、阻塞等原理实现，
// 后面章节会详细介绍。
// 本例让父进程先执行写入操作，子进程阻塞等待，父进程一口气将自己的字符串
// 写入到标准输出，完成后给子进程发信号通知它。
// 子进程收到来自父进程的信号后，解除阻塞，然后一口气将自己的字符串写入到
// 标准输出。
// 这样标准输出的结果不会杂乱，第一行一定是父进程输出的字符串，第二行一定
// 是子进程输出的字符串。
