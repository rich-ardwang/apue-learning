#include "apue.h"

// 全局静态函数声明
static void charatatime(char *);

int
main(void)
{
	// 进程ID
	pid_t		pid;

	// 父进程fork子进程
	if ((pid = fork()) < 0) {
		err_sys("fork error");
	} else if (pid == 0) {
		// 子进程调用全局静态函数输出字符串。
		// 注意：行缓冲时，换行符可以引发冲洗标准输出流操作。
		charatatime("output from child8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888\n");
	} else {
		// 父进程调用全局静态函数输出字符串。
		// 注意：同上
		charatatime("output from parent999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n");
	}
	// 父子进程退出，全缓冲时可引发冲洗流操作。
	exit(0);
}

// 该函数将标准IO缓冲区关闭，改为无缓冲，然后输出字符串。
static void
charatatime(char *str)
{
	char		*ptr;
	int			c;

	// 自定义标准IO的缓冲区，这里将标准输出缓冲区关闭，即改为无缓冲。
	setbuf(stdout, NULL);		/* set unbuffered */
	// 使用for循环方式一个字符一个字符去读取。
	for (ptr = str; (c = *ptr++) != 0; )
		// 每读取一个字符就向标准输出写入一个，注意是无缓冲。
		putc(c, stdout);
}

// 点评
// 本例主要演示两个进程之间的竞争条件（race condition）,父子进程都以无缓冲的方式
// 向标准输出写入字符串，内核非常快速的在父子进程之间进行切换，因此标准输出的结果是
// 父子进程交替写入的字符，并且每次执行都会不同。
// 标准输出的这种杂乱无章是由于父子进程产生了竞争条件造成的，解决办法是使用进程同步技术。
