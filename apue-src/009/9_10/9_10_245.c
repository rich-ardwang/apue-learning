#include "apue.h"
#include <errno.h>

// 自定义信号处理函数，专门处理SIGHUP（挂断信号）。
static void
sig_hup(int signo)
{
	// 并没有进行什么特别的处理，仅仅是打印出已收到SIGHUP信号，
	// 同时打印出该进程的进程ID。
	printf("SIGHUP received, pid = %ld\n", (long)getpid());
}

// 该函数打印出和进程、进程组有关的各种ID并手动冲洗标准输出流。
static void
pr_ids(char *name)
{
	// getpid()取得当前进程的进程ID
	// getppid()取得当前进程的父进程ID
	// getpgrp()取得当前进程所在进程组的ID
	// tcgetpgrp()返回该会话的前台进程组的ID，这个前台进程组与在文件描述符
	// fd上打开的终端相关联。
	printf("%s: pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld\n",
		name, (long)getpid(), (long)getppid(), (long)getpgrp(),
		(long)tcgetpgrp(STDIN_FILENO));
	// 手动冲洗标准输出流。
	fflush(stdout);
}

int
main(void)
{
	char		c;    // read函数读一个字节时需要使用
	pid_t		pid;  // 进程ID

	// 定义父进程名称，然后打印出一系列和父进程相关的ID。
	pr_ids("parent");
	// 父进程fork子进程
	if ((pid = fork()) < 0) {
		err_sys("fork error");
	} else if (pid > 0) {		/* parent */
		// 父进程睡眠5秒后正常退出，让子进程有充足的时间收到SIGHUP信号停止掉。
		sleep(5);				/* sleep to let child stop itself */
	} else {					/* child */
		// 定义子进程名称，然后打印出一系列和子进程相关的ID。
		pr_ids("child");
		// 子进程调用signal函数捕捉SIGHUP信号，并提供自定义处理该信号的方法。
		// 这样当子进程收到SIGUP信号时，自定义方法sig_hup将被回调。
		signal(SIGHUP, sig_hup);	/* establish signal handler */
		// 子进程调用kill函数自己给自己发送一个SIGTSTP（停止信号），类似于用
		// 终端挂起字符（Ctrl+Z)停止一个前台作业。
		// 由于没有捕捉SIGTSTP信号，子进程收到此信号后采用默认处理，也就是会
		// 立即停止。
		kill(getpid(), SIGTSTP);	/* stop ourself */
		// 子进程停止一段时间，父进程超过5秒醒来后退出了。
		// 此时，该子进程成为了孤儿进程，由init或upstart进程收养。
		// 而之前父子进程在同一个进程组中，组长父进程退出了，这个进程组只剩下一个
		// 子进程，则这个进程组成了孤儿进程组。
		// POSIX.1规定要向孤儿进程组中每一个停止状态的进程发送一个SIGHUP信号，
		// 之后再发送一个SIGCONT(继续信号)。
		// 注意：SIGHUP挂断信号，系统默认处理为终止进程，所以我们捕捉并自行处理
		// 了该信号，使子进程不会被终止。
		// 处理了SIGHUP信号后，子进程收到SIGCONT信号会从停止状态恢复为继续执行，
		// 那我们再此打印出和其相关的一系列进程ID。
		pr_ids("child");		/* prints only if we're continued */
		// 子进程从标准输入读入1个字节，注意read函数是系统调用，无缓冲机制。
		if (read(STDIN_FILENO, &c, 1) != 1)
			// 如果read出错，打印出errno。
			printf("read error %d on controlling TTY\n", errno);
	}
	// 正常退出（父子进程共用）。
	exit(0);
}

// 点评
// 本例重点演示会话、控制终端、进程组、孤儿进程组、作业控制（前后台进程组）等相关内容。
// 该程序由shell执行，所以shell是该程序进程的父进程，而该程序又fork了子进程，且父子
// 进程在同一个进程组，组长进程为父进程，shell进程自己在另一个进程组，shell把父子进程
// 放在一个前台进程组作为前台作业，且该前台作业与终端相关联（标准输入、输出等）。

// 进程组
// 每个进程除了有一个进程ID之外，还属于一个进程组，进程组是一个或多个进程的集合。
// 通常，进程组是在同一作业中结合起来的，同一进程组中的各进程接收来自同一终端的各种信号。
// 每个进程组有一个唯一的进程组ID，类似于进程ID，它是一个正整数。
// 每个进程组有一个组长进程，该进程组的ID就是其组长的进程ID。
// 进程组组长可以创建一个进程组、创建改组中的进程，然后终止。
// 某个进程组只要有一个进程存在，该进程组就存在，而与组长进程是否终止无关。
// 某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。
// 相关函数：
// getpgrp()和getpgid()可以取得进程组ID。
// setpgid()可以加入一个现有的进程组或者创建一个新进程组（setsid也能创建一个新进程组）。
// 注意：一个进程只能为它自己或它的子进程设置进程组ID，在它的子进程调用exec后，它就不再
// 更改该子进程的进程组ID。

// 会话
// 会话（session）是一个或多个进程组的集合。
// 进程使用setsid()函数创建一个新会话，规则如下：
// 如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话，具体为：
// 1).该进程变成新会话的会话首进程（session leader），会话首进程是创建该会话的进程。
// 2).该进程成为一个新进程组的组长，新进程组ID是该进程的进程ID。
// 3).该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，那么这种联系也被
// 切断。
// 如果该调用进程已经是一个进程组的组长，则setsid()返回出错。

// 保证一个进程不是进程组的组长的方法
// 通常fork一个子进程，然后让父进程终止，而子进程继续。
// 因为子进程继承了父进程的进程组ID，而其进程ID是新分配的，两者不可能相等。

// 控制终端与前后台进程组
// 一个会话可以有一个控制终端：终端设备（终端登录情况下）或伪终端设备（网络登录情况下）。
// 建立与控制终端连接的会话首进程称为控制进程。
// 一个会话中的几个进程组可以被分成一个前台进程组以及一个或多个后台进程组。
// 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。
// 键入中断键（Delete或Ctrl+C），会将中断信号发送至前台进程组的所有进程。
// 键入退出键（Ctrl+\），会将退出信号发送至前台进程组的所有进程。
// 如果终端接口检测到网络已断开连接，则将挂断信号发送至控制进程（会话首进程）。
// 相关函数：
// tcgetpgrp()获取前台进程组ID，需要给它传递一个文件描述符fd作为参数，终端设备在该
// fd上被打开。
// tcsetpgrp()可以设置某个进程组为前台进程组，前提是该会话必须有一个终端设备，此终端
// 设备在fd上被打开。
// tcgetsid()获取会话首进程的进程组ID，它等价于会话首进程的会话ID。

// 作业控制
// 作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个进程组可以访问终端以及
// 哪些作业在后台运行，需要以下支持：
// 1).支持作业控制的shell。
// 2).内核中的终端驱动程序必须支持作业控制。
// 3).内核必须提供对某些作业控制信号的支持。

// 作业控制与终端读写
// 前台进程组（前台作业）可以操作终端，即可以从终端设备读写数据。
// 后台进程组（后台作业）一般不可以操作终端，但这个可以设置为允许或不允许。
// 如果后台进程组不被允许操作终端，则它试图从终端读时，内核会向其发送SIGTTIN信号，
// 它试图向终端写时，内核会给它发送SIGTTOU信号。

// 孤儿进程组（orphaned process group）
// 定义1：一个进程组是孤儿进程组要满足，该进程组的每个成员的父进程要么是该组的成员，要么在其它会话中。
// 定义2：一个进程组不是孤儿进程组的条件是——该组有一个进程，其父进程在属于同一会话的另一个组中。
// 非孤儿进程组与孤儿进程组的区别：
// 1).非孤儿进程组，属于同一会话的另一个组中的父进程有机会重新启动该组中停止的进程，因此不需要发送信号。
// 2).孤儿进程组，如果父进程终止，且孤儿进程组中包含停止状态的进程，则要求内核向每一个停止状态的进程
// 发送SIGHUP信号，接着再向它们发送SIGCONT信号。

// 实验结果
/*
parent: pid = 9169, ppid = 2775, pgrp = 9169, tpgrp = 9169
child: pid = 9170, ppid = 9169, pgrp = 9169, tpgrp = 9169
SIGHUP received, pid = 9170
child: pid = 9170, ppid = 1580, pgrp = 9169, tpgrp = 2775
read error 5 on controlling TTY
*/

// 结果分析
// 1.父进程的父进程ID为shell的进程ID，父进程是自己进程组（9169）的组长。
// 2.父子进程在同一个进程组（9169）中。
// 3.shell把父子进程所在的进程组设定为前台进程组，可以访问终端，而shell
// 自己则成为后台进程组，不能访问终端。
// 4.子进程停止后，父进程终止，子进程成为孤儿进程，被upstart（1580）收养。
// 5.子进程所在进程组成了孤儿进程组，且子进程为停止状态，内核果然向它发送了
// SIGHUP信号。
// 6.之后子进程又收到SIGCONT信号继续执行。
// 7.但是子进程的前台进程组ID变成了2775，这是因为其父进程已经终止，shell
// 把它所在的进程组切换为后台进程组。
// 8.由于子进程所在进程组已经成为后台进程组，所以它试图从终端读数据时，内核
// 会向它发送SIGTTIN信号，但是由于这个进程组是孤儿进程组，所以POSIX规定
// read出错返回，errno设置为EIO（也就是5）。
